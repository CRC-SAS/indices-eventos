dplyr::ungroup()
# Para cada rango de fechas:
# 1. Validar cantidad de faltantes y cantidad de faltantes consecutivos
# 2. Si la validacion pasa, entonces aplicar funcion de agregacion. Sino, devolver NA.
estadisticos_x_fechas_procesables <- purrr::map_dfr(
.x = seq(from = 1, to = nrow(fechas.procesables)),
.f = function(fecha_seq_index) {
fecha.inicio  <- fechas.procesables[fecha_seq_index, "fecha.inicio"]
fecha.fin     <- fechas.procesables[fecha_seq_index, "fecha.fin"]
estadisticos_x_realizacion <- purrr::map_dfr(
.x = unique(registros.variable$realization),
.f = function(realization) {
datos.ventana <- registros.variable %>%
dplyr::filter(realization == !!realization) %>%
dplyr::filter(date >= fecha.inicio & date <= fecha.fin) %>%
dplyr::mutate(faltante = ifelse(is.na(value), TRUE, FALSE))
# Cantidad de faltantes (totales y secuencias de consecutivos)
cantidad.faltantes <- length(which(is.na(datos.ventana$value)))
cumple.validacion  <- TRUE
if (cantidad.faltantes > parametros.faltantes$maximo) {
cumple.validacion <- FALSE
} else if (! is.null(parametros.faltantes$consecutivos)) {
# Cumple la validacion de maxima cantidad de faltantes por mes.
# Validar faltantes consecutivos.
if (cantidad.faltantes > 0) {
faltantes.consecutivos     <- base::rle(datos.ventana$faltante)
max.faltantes.consecutivos <- max(faltantes.consecutivos$lengths[which(faltantes.consecutivos$values)])
} else {
# Al no haber faltantes, no puede haber faltantes consecutivos.
max.faltantes.consecutivos <- 0
}
if (max.faltantes.consecutivos > parametros.faltantes$consecutivos) {
cumple.validacion <- FALSE
}
}
# Calcular estadisticos
estadisticos <- purrr::map_dfr(
.x = seq(from = 1, to = length(estadisticos.calculables)),
.f = function(estadistico_seq_index) {
estadistico <- estadisticos.calculables[[estadistico_seq_index]]
if (! estadistico$validable || cumple.validacion) {
param <- append(list(x = datos.ventana$value), estadistico$parametros)
valor <- do.call(what = estadistico$funcion, args = param)
} else {
valor <- NA
}
return (tibble::tibble(estadistico = estadistico$id,
valor = valor))
}
)
return (tibble::tibble(realizacion = realization,
metodo_imputacion_id = 0) %>%
tidyr::crossing(estadisticos))
}
)
return (tibble::tibble(fecha_desde = fecha.inicio,
fecha_hasta = fecha.fin) %>%
tidyr::crossing(estadisticos_x_realizacion))
}
)
return (ubicacion %>% dplyr::select(dplyr::ends_with("_id")) %>%
dplyr::mutate(variable_id = variable, ancho_ventana_pentadas = ancho.ventana) %>%
tidyr::crossing(estadisticos_x_fechas_procesables))
}
CalcularEstadisticasUbicacion <- function(input.value, script, config, variables,
fecha.minima.inicio.pentada, fecha.maxima.inicio.pentada,
datos_climaticos_completos) {
# Obtener la ubicación para la cual se calcularán los índices
ubicacion <- input.value
# Identificar la columna con el id de la ubicación (usualmente station_id, o point_id)
id_column <- IdentificarIdColumn(ubicacion)
# Informar estado de la ejecución
script$info(glue::glue("Procesando estadisticas para la ubicación con ",
"{id_column} = {ubicacion %>% dplyr::pull(!!id_column)} ",
"(lon: {ubicacion$longitude}, lat: {ubicacion$latitude})"))
# Filtrar datos_climaticos_completos
datos.climaticos = datos_climaticos_completos %>%
dplyr::filter(!!rlang::sym(id_column) == dplyr::pull(ubicacion, !!id_column))
# Sabiendo la fecha minima de inicio de la pentada y la fecha maxima, calcular fechas procesables para cada ancho de ventana.
# Calcular estadisticos por variable y ancho de ventana.
estadisticas.ubicacion  <- purrr::map_dfr(
.x = config$params$ancho.ventana,
.f = function(ancho.ventana) {
# Genero un data frame de fechas procesables con 2 columnas: fecha inicio, fecha fin
fechas.procesables.inicio <- seq.pentadas(fecha.minima.inicio.pentada, fecha.maxima.inicio.pentada)
fechas.procesables        <- purrr::map_dfr(
.x = fechas.procesables.inicio,
.f = function(fecha) {
fecha.inicio.ventana <- fecha
fecha.fin.ventana    <- fecha.fin.pentada(sumar.pentadas(fecha.inicio.ventana, ancho.ventana - 1))
return (data.frame(fecha.inicio = fecha.inicio.ventana, fecha.fin = fecha.fin.ventana))
}
) %>% dplyr::filter(fecha.fin <= fecha.fin.pentada(fecha.maxima.inicio.pentada))
if (nrow(fechas.procesables) > 0) {
# Para cada variable, calcular las estadisticas correspondientes. Consolidar todos los resultados en un data frame.
# i. Calculo de estadisticas para la estacion.
estadisticas <- purrr::map_dfr(
.x = variables,
.f = CalcularEstadisticasUbicacionVariable,
fechas.procesables = fechas.procesables,
ubicacion = ubicacion,
datos.climaticos = datos.climaticos,
ancho.ventana = ancho.ventana,
parametros = config$params
)
return (estadisticas)
} else {
return (NULL)
}
}
)
if (nrow(estadisticas.ubicacion) > 0) {
# ii. Informar retorno de datos
script$info(paste("Retornando estadisticas",
"desde", min(estadisticas.ubicacion$fecha_desde),
"hasta", max(estadisticas.ubicacion$fecha_hasta),
"para la ubicación", dplyr::pull(ubicacion, !!id_column)))
} else {
# No hay datos nuevos para agregar
script$info(paste("No hay nuevas fechas procesables para la ubicación", dplyr::pull(ubicacion, !!id_column)))
}
return (estadisticas.ubicacion)
}
# Crear tarea distribuida y ejecutarla
task.estadisticas <- Task$new(parent.script = script,
func.name = "CalcularEstadisticasUbicacion",
packages = list.of.packages)
# Informar inicio de ejecución
script$info(paste0("Calculando estadisticas moviles para un ancho de venta de (",
paste0(config$params$ancho.ventana, collapse = ", "), ") pentadas"))
# Ejecutar tarea distribuida
resultados.estadisticas <- task.estadisticas$run(number.of.processes = config$max.procesos,
input.values = ubicaciones_a_procesar,
config = config, variables = c("tmax", "tmin", "prcp"),
fecha.minima.inicio.pentada = fecha.minima.inicio.pentada,
fecha.maxima.inicio.pentada = fecha.maxima.inicio.pentada,
datos_climaticos_completos = datos_climaticos_generados)
# Si hay errores, terminar ejecucion
task.estadisticas.errors <- task.estadisticas$getErrors()
task.estadisticas.errors
CalcularEstadisticasUbicacionVariable  <- function(variable, fechas.procesables, ubicacion,
datos.climaticos, ancho.ventana, parametros) {
# Identificar la columna con el id de la ubicación (usualmente station_id, o point_id)
id_column <- IdentificarIdColumn(ubicacion)
# Definir parametros para variables
politicas.ventana        <- purrr::keep(
.x = parametros$faltantes,
.p = function(politica) {
return (politica$ancho.ventan == ancho.ventana) }
)[[1]]$politica
parametros.faltantes     <- politicas.ventana[[variable]]
estadisticos.calculables <- parametros$estadisticos[[variable]]
# Buscar todos los datos posibles de una vez. El listado devuelto tiene que tener todas las fechas
# posibles. Donde no hay datos, debe figurar la fecha con valor NA.
# Como cada variable está en un columna diferente, para tomar datos de una sola variable
# se hace un select sobre la columna asociada a la variable y no un filter!!
registros.variable <- datos.climaticos %>%
dplyr::select(!!rlang::sym(id_column), realization, date, value = !!variable) %>%
dplyr::group_by(!!rlang::sym(id_column), realization) %>%
tidyr::complete(date = base::seq.Date(min(fechas.procesables$fecha.inicio),
max(fechas.procesables$fecha.fin), by = "days")) %>%
dplyr::ungroup()
# Para cada rango de fechas:
# 1. Validar cantidad de faltantes y cantidad de faltantes consecutivos
# 2. Si la validacion pasa, entonces aplicar funcion de agregacion. Sino, devolver NA.
estadisticos_x_fechas_procesables <- purrr::map_dfr(
.x = seq(from = 1, to = nrow(fechas.procesables)),
.f = function(fecha_seq_index) {
fecha.inicio  <- fechas.procesables[fecha_seq_index, "fecha.inicio"]
fecha.fin     <- fechas.procesables[fecha_seq_index, "fecha.fin"]
estadisticos_x_realizacion <- purrr::map_dfr(
.x = unique(registros.variable$realization),
.f = function(realization) {
datos.ventana <- registros.variable %>%
dplyr::filter(realization == !!realization) %>%
dplyr::filter(date >= fecha.inicio & date <= fecha.fin) %>%
dplyr::mutate(faltante = ifelse(is.na(value), TRUE, FALSE))
# Cantidad de faltantes (totales y secuencias de consecutivos)
cantidad.faltantes <- length(which(is.na(datos.ventana$value)))
cumple.validacion  <- TRUE
if (cantidad.faltantes > parametros.faltantes$maximo) {
cumple.validacion <- FALSE
} else if (! is.null(parametros.faltantes$consecutivos)) {
# Cumple la validacion de maxima cantidad de faltantes por mes.
# Validar faltantes consecutivos.
if (cantidad.faltantes > 0) {
faltantes.consecutivos     <- base::rle(datos.ventana$faltante)
max.faltantes.consecutivos <- max(faltantes.consecutivos$lengths[which(faltantes.consecutivos$values)])
} else {
# Al no haber faltantes, no puede haber faltantes consecutivos.
max.faltantes.consecutivos <- 0
}
if (max.faltantes.consecutivos > parametros.faltantes$consecutivos) {
cumple.validacion <- FALSE
}
}
# Calcular estadisticos
estadisticos <- purrr::map_dfr(
.x = seq(from = 1, to = length(estadisticos.calculables)),
.f = function(estadistico_seq_index) {
estadistico <- estadisticos.calculables[[estadistico_seq_index]]
if (! estadistico$validable || cumple.validacion) {
param <- append(list(x = datos.ventana$value), estadistico$parametros)
valor <- do.call(what = estadistico$funcion, args = param)
} else {
valor <- NA
}
return (tibble::tibble(estadistico = estadistico$id,
valor = valor))
}
)
return (tibble::tibble(realizacion = realization,
metodo_imputacion_id = 0) %>%
tidyr::crossing(estadisticos))
}
)
return (tibble::tibble(fecha_desde = fecha.inicio,
fecha_hasta = fecha.fin) %>%
tidyr::crossing(estadisticos_x_realizacion))
}
)
return (ubicacion %>% dplyr::select(dplyr::ends_with("_id")) %>%
dplyr::mutate(variable_id = variable, ancho_ventana_pentadas = ancho.ventana) %>%
tidyr::crossing(estadisticos_x_fechas_procesables))
}
CalcularEstadisticasUbicacion <- function(input.value, script, config, variables,
fecha.minima.inicio.pentada, fecha.maxima.inicio.pentada,
datos_climaticos_completos) {
# Obtener la ubicación para la cual se calcularán los índices
ubicacion <- input.value
# Identificar la columna con el id de la ubicación (usualmente station_id, o point_id)
id_column <- IdentificarIdColumn(ubicacion)
# Informar estado de la ejecución
script$info(glue::glue("Procesando estadisticas para la ubicación con ",
"{id_column} = {ubicacion %>% dplyr::pull(!!id_column)} ",
"(lon: {ubicacion$longitude}, lat: {ubicacion$latitude})"))
# Filtrar datos_climaticos_completos
datos.climaticos = datos_climaticos_completos %>%
dplyr::filter(!!rlang::sym(id_column) == dplyr::pull(ubicacion, !!id_column))
# Sabiendo la fecha minima de inicio de la pentada y la fecha maxima, calcular fechas procesables para cada ancho de ventana.
# Calcular estadisticos por variable y ancho de ventana.
estadisticas.ubicacion  <- purrr::map_dfr(
.x = config$params$ancho.ventana,
.f = function(ancho.ventana) {
# Genero un data frame de fechas procesables con 2 columnas: fecha inicio, fecha fin
fechas.procesables.inicio <- seq.pentadas(fecha.minima.inicio.pentada, fecha.maxima.inicio.pentada)
fechas.procesables        <- purrr::map_dfr(
.x = fechas.procesables.inicio,
.f = function(fecha) {
fecha.inicio.ventana <- fecha
fecha.fin.ventana    <- fecha.fin.pentada(sumar.pentadas(fecha.inicio.ventana, ancho.ventana - 1))
return (data.frame(fecha.inicio = fecha.inicio.ventana, fecha.fin = fecha.fin.ventana))
}
) %>% dplyr::filter(fecha.fin <= fecha.fin.pentada(fecha.maxima.inicio.pentada))
if (nrow(fechas.procesables) > 0) {
# Para cada variable, calcular las estadisticas correspondientes. Consolidar todos los resultados en un data frame.
# i. Calculo de estadisticas para la estacion.
estadisticas <- purrr::map_dfr(
.x = variables,
.f = CalcularEstadisticasUbicacionVariable,
fechas.procesables = fechas.procesables,
ubicacion = ubicacion,
datos.climaticos = datos.climaticos,
ancho.ventana = ancho.ventana,
parametros = config$params
)
return (estadisticas)
} else {
return (NULL)
}
}
)
if (nrow(estadisticas.ubicacion) > 0) {
# ii. Informar retorno de datos
script$info(paste("Retornando estadisticas",
"desde", min(estadisticas.ubicacion$fecha_desde),
"hasta", max(estadisticas.ubicacion$fecha_hasta),
"para la ubicación", dplyr::pull(ubicacion, !!id_column)))
} else {
# No hay datos nuevos para agregar
script$info(paste("No hay nuevas fechas procesables para la ubicación", dplyr::pull(ubicacion, !!id_column)))
}
return (estadisticas.ubicacion)
}
# Crear tarea distribuida y ejecutarla
task.estadisticas <- Task$new(parent.script = script,
func.name = "CalcularEstadisticasUbicacion",
packages = list.of.packages)
# Informar inicio de ejecución
script$info(paste0("Calculando estadisticas moviles para un ancho de venta de (",
paste0(config$params$ancho.ventana, collapse = ", "), ") pentadas"))
# Ejecutar tarea distribuida
resultados.estadisticas <- task.estadisticas$run(number.of.processes = config$max.procesos,
input.values = ubicaciones_a_procesar,
config = config, variables = c("tmax", "tmin", "prcp"),
fecha.minima.inicio.pentada = fecha.minima.inicio.pentada,
fecha.maxima.inicio.pentada = fecha.maxima.inicio.pentada,
datos_climaticos_completos = datos_climaticos_generados)
task.estadisticas.errors <- task.estadisticas$getErrors()
# Transformar resultados a un objeto de tipo tibble
resultados.estadisticas.tibble <- resultados.estadisticas %>% purrr::map_dfr(~.x)
# Guardar resultados en un archivo fácil de compartir
feather::write_feather(resultados.estadisticas.tibble,
glue::glue("{config$dir$data}/{config$files$estadisticas_moviles$resultados}"))
task.estadisticas.errors
# -----------------------------------------------------------------------------#
# --- PASO 4. Definir funciones de agregacion ----
# -----------------------------------------------------------------------------#
IdentificarIdColumn <- function(ubicacion) {
if ("station_id" %in% colnames(ubicacion)) {
id_column <- "station_id"
} else if ("point_id" %in% colnames(ubicacion)) {
id_column <- "point_id"
} else {
id_column <- ubicacion %>% dplyr::select(dplyr::ends_with('_id')) %>%
base::colnames() %>% base::sort() %>% dplyr::first()
}
return (id_column)
}
ContarFaltantes <- function(x) {
return (length(which(is.na(x))))
}
ContarDisponibles <- function(x) {
return (length(x) - length(which(is.na(x))))
}
CalcularOcurrencia <- function(x, umbral) {
return (length(which(x >= umbral)))
}
CalcularEstadisticasUbicacionVariable  <- function(variable, fechas.procesables, ubicacion,
datos.climaticos, ancho.ventana, parametros) {
# Identificar la columna con el id de la ubicación (usualmente station_id, o point_id)
id_column <- IdentificarIdColumn(ubicacion)
# Definir parametros para variables
politicas.ventana        <- purrr::keep(
.x = parametros$faltantes,
.p = function(politica) {
return (politica$ancho.ventana == ancho.ventana) }
)[[1]]$politica
parametros.faltantes     <- politicas.ventana[[variable]]
estadisticos.calculables <- parametros$estadisticos[[variable]]
# Buscar todos los datos posibles de una vez. El listado devuelto tiene que tener todas las fechas
# posibles. Donde no hay datos, debe figurar la fecha con valor NA.
# Como cada variable está en un columna diferente, para tomar datos de una sola variable
# se hace un select sobre la columna asociada a la variable y no un filter!!
registros.variable <- datos.climaticos %>%
dplyr::select(!!rlang::sym(id_column), realization, date, value = !!variable) %>%
dplyr::group_by(!!rlang::sym(id_column), realizacion) %>%
tidyr::complete(date = base::seq.Date(min(fechas.procesables$fecha.inicio),
max(fechas.procesables$fecha.fin), by = "days")) %>%
dplyr::ungroup()
# Para cada rango de fechas:
# 1. Validar cantidad de faltantes y cantidad de faltantes consecutivos
# 2. Si la validacion pasa, entonces aplicar funcion de agregacion. Sino, devolver NA.
estadisticos_x_fechas_procesables <- purrr::map_dfr(
.x = seq(from = 1, to = nrow(fechas.procesables)),
.f = function(fecha_seq_index) {
fecha.inicio  <- fechas.procesables[fecha_seq_index, "fecha.inicio"]
fecha.fin     <- fechas.procesables[fecha_seq_index, "fecha.fin"]
estadisticos_x_realizacion <- purrr::map_dfr(
.x = unique(registros.variable$realization),
.f = function(realization) {
datos.ventana <- registros.variable %>%
dplyr::filter(realization == !!realization) %>%
dplyr::filter(date >= fecha.inicio & date <= fecha.fin) %>%
dplyr::mutate(faltante = ifelse(is.na(value), TRUE, FALSE))
# Cantidad de faltantes (totales y secuencias de consecutivos)
cantidad.faltantes <- length(which(is.na(datos.ventana$value)))
cumple.validacion  <- TRUE
if (cantidad.faltantes > parametros.faltantes$maximo) {
cumple.validacion <- FALSE
} else if (! is.null(parametros.faltantes$consecutivos)) {
# Cumple la validacion de maxima cantidad de faltantes por mes.
# Validar faltantes consecutivos.
if (cantidad.faltantes > 0) {
faltantes.consecutivos     <- base::rle(datos.ventana$faltante)
max.faltantes.consecutivos <- max(faltantes.consecutivos$lengths[which(faltantes.consecutivos$values)])
} else {
# Al no haber faltantes, no puede haber faltantes consecutivos.
max.faltantes.consecutivos <- 0
}
if (max.faltantes.consecutivos > parametros.faltantes$consecutivos) {
cumple.validacion <- FALSE
}
}
# Calcular estadisticos
estadisticos <- purrr::map_dfr(
.x = seq(from = 1, to = length(estadisticos.calculables)),
.f = function(estadistico_seq_index) {
estadistico <- estadisticos.calculables[[estadistico_seq_index]]
if (! estadistico$validable || cumple.validacion) {
param <- append(list(x = datos.ventana$value), estadistico$parametros)
valor <- do.call(what = estadistico$funcion, args = param)
} else {
valor <- NA
}
return (tibble::tibble(estadistico = estadistico$id,
valor = valor))
}
)
return (tibble::tibble(realizacion = realization,
metodo_imputacion_id = 0) %>%
tidyr::crossing(estadisticos))
}
)
return (tibble::tibble(fecha_desde = fecha.inicio,
fecha_hasta = fecha.fin) %>%
tidyr::crossing(estadisticos_x_realizacion))
}
)
return (ubicacion %>% dplyr::select(dplyr::ends_with("_id")) %>%
dplyr::mutate(variable_id = variable, ancho_ventana_pentadas = ancho.ventana) %>%
tidyr::crossing(estadisticos_x_fechas_procesables))
}
CalcularEstadisticasUbicacion <- function(input.value, script, config, variables,
fecha.minima.inicio.pentada, fecha.maxima.inicio.pentada,
datos_climaticos_completos) {
# Obtener la ubicación para la cual se calcularán los índices
ubicacion <- input.value
# Identificar la columna con el id de la ubicación (usualmente station_id, o point_id)
id_column <- IdentificarIdColumn(ubicacion)
# Informar estado de la ejecución
script$info(glue::glue("Procesando estadisticas para la ubicación con ",
"{id_column} = {ubicacion %>% dplyr::pull(!!id_column)} ",
"(lon: {ubicacion$longitude}, lat: {ubicacion$latitude})"))
# Filtrar datos_climaticos_completos
datos.climaticos = datos_climaticos_completos %>%
dplyr::filter(!!rlang::sym(id_column) == dplyr::pull(ubicacion, !!id_column))
# Sabiendo la fecha minima de inicio de la pentada y la fecha maxima, calcular fechas procesables para cada ancho de ventana.
# Calcular estadisticos por variable y ancho de ventana.
estadisticas.ubicacion  <- purrr::map_dfr(
.x = config$params$ancho.ventana,
.f = function(ancho.ventana) {
# Genero un data frame de fechas procesables con 2 columnas: fecha inicio, fecha fin
fechas.procesables.inicio <- seq.pentadas(fecha.minima.inicio.pentada, fecha.maxima.inicio.pentada)
fechas.procesables        <- purrr::map_dfr(
.x = fechas.procesables.inicio,
.f = function(fecha) {
fecha.inicio.ventana <- fecha
fecha.fin.ventana    <- fecha.fin.pentada(sumar.pentadas(fecha.inicio.ventana, ancho.ventana - 1))
return (data.frame(fecha.inicio = fecha.inicio.ventana, fecha.fin = fecha.fin.ventana))
}
) %>% dplyr::filter(fecha.fin <= fecha.fin.pentada(fecha.maxima.inicio.pentada))
if (nrow(fechas.procesables) > 0) {
# Para cada variable, calcular las estadisticas correspondientes. Consolidar todos los resultados en un data frame.
# i. Calculo de estadisticas para la estacion.
estadisticas <- purrr::map_dfr(
.x = variables,
.f = CalcularEstadisticasUbicacionVariable,
fechas.procesables = fechas.procesables,
ubicacion = ubicacion,
datos.climaticos = datos.climaticos,
ancho.ventana = ancho.ventana,
parametros = config$params
)
return (estadisticas)
} else {
return (NULL)
}
}
)
if (nrow(estadisticas.ubicacion) > 0) {
# ii. Informar retorno de datos
script$info(paste("Retornando estadisticas",
"desde", min(estadisticas.ubicacion$fecha_desde),
"hasta", max(estadisticas.ubicacion$fecha_hasta),
"para la ubicación", dplyr::pull(ubicacion, !!id_column)))
} else {
# No hay datos nuevos para agregar
script$info(paste("No hay nuevas fechas procesables para la ubicación", dplyr::pull(ubicacion, !!id_column)))
}
return (estadisticas.ubicacion)
}
# Crear tarea distribuida y ejecutarla
task.estadisticas <- Task$new(parent.script = script,
func.name = "CalcularEstadisticasUbicacion",
packages = list.of.packages)
# Informar inicio de ejecución
script$info(paste0("Calculando estadisticas moviles para un ancho de venta de (",
paste0(config$params$ancho.ventana, collapse = ", "), ") pentadas"))
# Ejecutar tarea distribuida
resultados.estadisticas <- task.estadisticas$run(number.of.processes = config$max.procesos,
input.values = ubicaciones_a_procesar,
config = config, variables = c("tmax", "tmin", "prcp"),
fecha.minima.inicio.pentada = fecha.minima.inicio.pentada,
fecha.maxima.inicio.pentada = fecha.maxima.inicio.pentada,
datos_climaticos_completos = datos_climaticos_generados)
# Si hay errores, terminar ejecucion
task.estadisticas.errors <- task.estadisticas$getErrors()
task.estadisticas.errors
# Transformar resultados a un objeto de tipo tibble
resultados.estadisticas.tibble <- resultados.estadisticas %>% purrr::map_dfr(~.x)
# Guardar resultados en un archivo fácil de compartir
feather::write_feather(resultados.estadisticas.tibble,
glue::glue("{config$dir$data}/{config$files$estadisticas_moviles$resultados}"))
id_column <- IdentificarIdColumn(ubicaciones_a_procesar %>% dplyr::top_n(1))
ubicaciones_a_procesar
id_column <- IdentificarIdColumn(ubicaciones_a_procesar %>% dplyr::top_n(1))
id_column
for (error.obj in task.estadisticas.errors) {
id_column <- IdentificarIdColumn(ubicaciones_a_procesar %>% dplyr::top_n(1))
script$warn(paste0("({id_column}=", error.obj$input.value[[id_column]], "): ", error.obj$error))
}
for (error.obj in task.estadisticas.errors) {
id_column <- IdentificarIdColumn(ubicaciones_a_procesar %>% dplyr::top_n(1))
script$warn(glue::glue("({id_column}={error.obj$input.value[[id_column]]): {error.obj$error}"))
}
for (error.obj in task.estadisticas.errors) {
id_column <- IdentificarIdColumn(ubicaciones_a_procesar %>% dplyr::top_n(1))
script$warn(glue::glue("({id_column}={error.obj$input.value[[id_column]]}): {error.obj$error}"))
}
source(glue::glue("{config$dir$lib}/Helpers.R"), echo = FALSE)
source('~/RStudioProjects/IndicesGenerador/EstadisticasMoviles/01_estadisticas_moviles.R')
